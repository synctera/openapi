# Go API client for {{packageName}}

{{#appDescriptionWithNewLines}}
{{{appDescriptionWithNewLines}}}
{{/appDescriptionWithNewLines}}

## Overview
This API client was generated by the [OpenAPI Generator](https://openapi-generator.tech) project.  By using the [OpenAPI-spec](https://www.openapis.org/) from a remote server, you can easily generate an API client.

- API version: {{appVersion}}
- Package version: {{packageVersion}}
{{^hideGenerationTimestamp}}
- Build date: {{generatedDate}}
{{/hideGenerationTimestamp}}
- Build package: {{generatorClass}}
{{#infoUrl}}
For more information, please visit [{{{infoUrl}}}]({{{infoUrl}}})
{{/infoUrl}}

## Installation

Install with `go get`:

```shell
go get {{gitHost}}/{{gitUserId}}/{{gitRepoId}}
```

Import the package:

```golang
import (
	{{packageName}} "{{gitHost}}/{{gitUserId}}/{{gitRepoId}}"
)
```

## Usage example
This is the example for MainAPI SDK usage, please change as needed.

### URL and client configration
```golang
import (
	"net/http"
	"net/url"
	mainapi "gitlab.com/synctera/clients/mainapi-client-go/v0"
	"gitlab.com/synctera/gocommon/httpclient"
)

type MainAPIClient struct {
	client        *http.Client
	openAPIClient *mainapi.APIClient
	baseURL       string
}

func NewMainAPIClient() *MainAPIClient {
	baseURL, err := serviceurls.GetURLForService("mainapi")
	if err != nil {
		log.Fatal().Err(err).Msg("failed to get mainapi URL")
	}
	client := httpclient.Default(baseURL)
	mainAPIURL, err := url.Parse(baseURL)
	if err != nil {
		log.Fatal().Err(err).Msg("failed to parse mainapi URL")
	}

	openAPIConf := mainapi.NewConfiguration()
	// Need to preserve the client for automatic GCP and Synctera identity support
	openAPIConf.HTTPClient = httpclient.Default(baseURL)
	openAPIConf.UserAgent = "{{packageName}}"
	openAPIConf.Scheme = mainAPIURL.Scheme
	openAPIConf.Host = mainAPIURL.Host

	openAPIClient := mainapi.NewAPIClient(openAPIConf)

	return &MainAPIClient{
		client:        client,
		openAPIClient: openAPIClient,
		baseURL:       baseURL,
	}
}
```

### GET /v0/accounts/products
Corresponding URL: GET /v0/accounts/products&product_types=INTEREST&start_date=2022-01-01
```golang
func (m *MainAPIClient) GetAccountProducts(ctx context.Context) (mainapi.AccountProductList, error) {
	startDateTime, _ := time.Parse("2006-01-02", "2022-01-01")
	startDate := types.Date{Time: startDateTime}
	products, resp, err := m.APIClient.AccountProductsApi.ListAccountProducts(ctx).ProductType("INTEREST").StartDate(startDate).Execute()
	if err != nil {
		// handle the error, this includes http response code
	}
	// resp handling. resp.Body no need to be closed
	return products, nil
}
```

Corresponding URL: PATCH /v0/accounts/af029ff5-6b15-4802-a9c0-c183e8796a40 with status update
```golang
func (m *MainAPIClient) PatchAccount(ctx context.Context) (account mainapi.Account, err error) {
	newStatus := mainapi.STATUS_RESTRICTED
	patchFeild := mainapi.Account{
		Status: &newStatus, 
	}
	account, _, err := accountm.openAPIClient.AccountsApi.PatchAccount(ctx, "af029ff5-6b15-4802-a9c0-c183e8796a40").Account(patchFeild).Execute()
	if err != nil {
		// handle the error, this includes http response code
	}
	// resp handling. resp.Body no need to be closed
	return account, nil
}
```


## Documentation for API Endpoints

All URIs are relative to *{{basePath}}*

Class | Method | HTTP request | Description
------------ | ------------- | ------------- | -------------
{{#apiInfo}}{{#apis}}{{#operations}}{{#operation}}*{{classname}}* | [**{{operationId}}**]({{apiDocPath}}{{classname}}.md#{{operationIdLowerCase}}) | **{{httpMethod}}** {{path}} | {{summary}}
{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}

## Documentation For Models

{{#models}}{{#model}} - [{{{classname}}}]({{modelDocPath}}{{{classname}}}.md)
{{/model}}{{/models}}

## Documentation For Authorization

{{^authMethods}} Endpoints do not require authorization.
{{/authMethods}}{{#authMethods}}{{#last}} Authentication schemes defined for the API:{{/last}}{{/authMethods}}
{{#authMethods}}

### {{{name}}}

{{#isApiKey}}
- **Type**: API key
- **API key parameter name**: {{{keyParamName}}}
- **Location**: {{#isKeyInQuery}}URL query string{{/isKeyInQuery}}{{#isKeyInHeader}}HTTP header{{/isKeyInHeader}}

Note, each API key must be added to a map of `map[string]APIKey` where the key is: {{keyParamName}} and passed in as the auth context for each request.

{{/isApiKey}}
{{#isBasic}}
{{#isBasicBearer}}
- **Type**: HTTP Bearer token authentication

Example

```golang
auth := context.WithValue(context.Background(), sw.ContextAccessToken, "BEARERTOKENSTRING")
r, err := client.Service.Operation(auth, args)
```

{{/isBasicBearer}}
{{#isBasicBasic}}
- **Type**: HTTP basic authentication

Example

```golang
auth := context.WithValue(context.Background(), sw.ContextBasicAuth, sw.BasicAuth{
    UserName: "username",
    Password: "password",
})
r, err := client.Service.Operation(auth, args)
```

{{/isBasicBasic}}
{{#isHttpSignature}}
- **Type**: HTTP signature authentication

Example

```golang
	authConfig := sw.HttpSignatureAuth{
		KeyId:                "my-key-id",
		PrivateKeyPath:       "rsa.pem",
		Passphrase:           "my-passphrase",
		SigningScheme:        sw.HttpSigningSchemeHs2019,
		SignedHeaders:        []string{
			sw.HttpSignatureParameterRequestTarget, // The special (request-target) parameter expresses the HTTP request target.
			sw.HttpSignatureParameterCreated,       // Time when request was signed, formatted as a Unix timestamp integer value.
			"Host",                                 // The Host request header specifies the domain name of the server, and optionally the TCP port number.
			"Date",                                 // The date and time at which the message was originated.
			"Content-Type",                         // The Media type of the body of the request.
			"Digest",                               // A cryptographic digest of the request body.
		},
		SigningAlgorithm:     sw.HttpSigningAlgorithmRsaPSS,
		SignatureMaxValidity: 5 * time.Minute,
	}
	var authCtx context.Context
	var err error
	if authCtx, err = authConfig.ContextWithValue(context.Background()); err != nil {
		// Process error
	}
	r, err = client.Service.Operation(auth, args)

```
{{/isHttpSignature}}
{{/isBasic}}
{{#isOAuth}}

- **Type**: OAuth
- **Flow**: {{{flow}}}
- **Authorization URL**: {{{authorizationUrl}}}
- **Scopes**: {{^scopes}}N/A{{/scopes}}
{{#scopes}} - **{{{scope}}}**: {{{description}}}
{{/scopes}}

Example

```golang
auth := context.WithValue(context.Background(), sw.ContextAccessToken, "ACCESSTOKENSTRING")
r, err := client.Service.Operation(auth, args)
```

Or via OAuth2 module to automatically refresh tokens and perform user authentication.

```golang
import "golang.org/x/oauth2"

/* Perform OAuth2 round trip request and obtain a token */

tokenSource := oauth2cfg.TokenSource(createContext(httpClient), &token)
auth := context.WithValue(oauth2.NoContext, sw.ContextOAuth2, tokenSource)
r, err := client.Service.Operation(auth, args)
```

{{/isOAuth}}
{{/authMethods}}

## Documentation for Utility Methods

Due to the fact that model structure members are all pointers, this package contains
a number of utility functions to easily obtain pointers to values of basic types.
Each of these functions takes a value of the given basic type and returns a pointer to it:

* `PtrBool`
* `PtrInt`
* `PtrInt32`
* `PtrInt64`
* `PtrFloat`
* `PtrFloat32`
* `PtrFloat64`
* `PtrString`
* `PtrTime`

## Author

{{#apiInfo}}{{#apis}}{{#-last}}{{infoEmail}}
{{/-last}}{{/apis}}{{/apiInfo}}
